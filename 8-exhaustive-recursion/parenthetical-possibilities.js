// Write a function, parentheticalPossibilities, that takes in a string as an argument. The function should return an array containing all of the strings that could be generated by expanding all parentheses of the string into its possibilities.
// For example, the possibilities for 'x(mn)yz' are 'xmyz', 'xnyz'.

// Approach
// Break the problem down recursively until s length is 0 and return ['']
// Iterate through the string
//   if first char is a letter, take the letter and hold it
//   if the first char is an open parentheses, loop until the close parentheses
//      In each loop, call the function keeping only 1 of each of the char in the parentheses and the remainder of the string
//      Add the current char to the beginning of each result string in the array

// Time complexity: O(m^n) exponential where m is the max group size and n is the number of groups
// Space complexity: O(m^n) exponential
const parentheticalPossibilities = (s) => {
  if (s.length === 0) return [''];

  const first = s[0];
  const possibilities = [];
  
  if (first === '(') {
    const endIndex = s.indexOf(')');
    for (let i = 1; i < endIndex; i++) {
      const subPoss = parentheticalPossibilities(s.slice(endIndex + 1));
      for (let sub of subPoss) {
        possibilities.push(s[i] + sub);
      }
    }
  } else { // first letter is a character
    const subPoss = parentheticalPossibilities(s.slice(1));
    for (let sub of subPoss) {
      possibilities.push(first + sub);
    }
  }

  return possibilities;
};

/*****************************************************************************/

const parentheticalPossibilitiesCleaner = (s) => {
  if (s.length === 0) return [''];

  const { remainder, charOptions } = getOptions(s);
  const subPoss = parentheticalPossibilities(remainder);
  const possibilities = [];

  for (let sub of subPoss) {
    for (let i = 0; i < charOptions.length; i++) {
      possibilities.push(charOptions[i] + sub);
    }
  }

  return possibilities;
};

// Find the remainder to run recursively and char options from within a set of parentheses
const getOptions = (s) => {
  const first = s[0];
  let remainder, charOptions;
  
  if (first === '(') {
    const endIndex = s.indexOf(')');
    remainder = s.slice(endIndex + 1);
    charOptions = s.slice(1, endIndex).split('');
  } else { // first character is a letter
    remainder = s.slice(1);
    charOptions = [first];
  }
  
  return { remainder, charOptions };
}

// parentheticalPossibilities('x(mn)yz'); // -> 
// [ 'xmyz', 'xnyz' ]

// parentheticalPossibilities("(qr)ab(stu)c"); // ->
// [ 'qabsc', 'qabtc', 'qabuc', 'rabsc', 'rabtc', 'rabuc' ]

// parentheticalPossibilities("taco"); // ->
// ['taco']

// parentheticalPossibilities(""); // ->
// ['']

// parentheticalPossibilities("(etc)(blvd)(cat)"); // ->
// [
//  'ebc', 'eba', 'ebt', 'elc', 'ela',
//  'elt', 'evc', 'eva', 'evt', 'edc',
//  'eda', 'edt', 'tbc', 'tba', 'tbt',
//  'tlc', 'tla', 'tlt', 'tvc', 'tva',
//  'tvt', 'tdc', 'tda', 'tdt', 'cbc',
//  'cba', 'cbt', 'clc', 'cla', 'clt',
//  'cvc', 'cva', 'cvt', 'cdc', 'cda',
//  'cdt'
// ]
